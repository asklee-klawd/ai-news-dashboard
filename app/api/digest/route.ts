import { NextResponse } from 'next/server';
import { aggregateNews } from '@/lib/sources';
import { scoreRelevance } from '@/lib/utils/keywords';

export const dynamic = 'force-dynamic';

interface DigestItem {
  title: string;
  url: string;
  source: string;
  isHot: boolean;
}

interface DigestResponse {
  date: string;
  greeting: string;
  dontMiss: DigestItem[];
  news: DigestItem[];
  toolOfTheDay: DigestItem | null;
  formatted: string;
  itemCount: number;
}

function getGreeting(): string {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good morning';
  if (hour < 17) return 'Good afternoon';
  return 'Good evening';
}

export async function GET(request: Request): Promise<NextResponse<DigestResponse>> {
  const { searchParams } = new URL(request.url);
  const format = searchParams.get('format') || 'default';
  try {
    const data = await aggregateNews(30);
    
    // Score and sort by relevance
    const scored = data.items.map(item => ({
      ...item,
      relevance: scoreRelevance(item.title),
    })).sort((a, b) => b.relevance - a.relevance);

    // Top items for "Don't Miss" (highest relevance + hot)
    const dontMiss = scored
      .filter(item => item.relevance > 10 || item.isHot)
      .slice(0, 3)
      .map(({ title, url, source, isHot }) => ({ title, url, source, isHot: isHot || false }));

    // Regular news (next best items)
    const dontMissUrls = new Set(dontMiss.map(d => d.url));
    const news = scored
      .filter(item => !dontMissUrls.has(item.url))
      .slice(0, 5)
      .map(({ title, url, source, isHot }) => ({ title, url, source, isHot: isHot || false }));

    // Tool of the day (look for tools, libraries, launches)
    const toolKeywords = ['launch', 'release', 'tool', 'library', 'framework', 'open source', 'github'];
    const toolOfTheDay = scored.find(item => 
      toolKeywords.some(kw => item.title.toLowerCase().includes(kw)) &&
      !dontMissUrls.has(item.url) &&
      !news.some(n => n.url === item.url)
    );

    // Format the digest as text
    const today = new Date().toLocaleDateString('en-US', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });

    let formatted: string;

    if (format === 'whatsapp') {
      // WhatsApp-friendly format: no markdown, compact, clean
      formatted = `üóûÔ∏è AI NEWS ‚Äî ${today.toUpperCase()}\n\n`;

      if (dontMiss.length > 0) {
        formatted += `üî• DON'T MISS\n\n`;
        dontMiss.forEach((item, i) => {
          formatted += `${i + 1}. ${item.title}\n${item.url}\n\n`;
        });
      }

      if (news.length > 0) {
        formatted += `üì∞ MORE NEWS\n\n`;
        news.forEach((item, i) => {
          formatted += `${i + 1}. ${item.title}\n${item.url}\n\n`;
        });
      }

      if (toolOfTheDay) {
        formatted += `üí° TOOL OF THE DAY\n\n`;
        formatted += `${toolOfTheDay.title}\n${toolOfTheDay.url}`;
      }

      if (dontMiss.length === 0 && news.length === 0) {
        formatted += `Quiet day in AI news. Check back later!`;
      }
    } else {
      // Default format with markdown
      formatted = `üóûÔ∏è **Daily AI News ‚Äî ${today}**\n\n`;

      if (dontMiss.length > 0) {
        formatted += `üî• **DON'T MISS:**\n`;
        dontMiss.forEach(item => {
          formatted += `‚Ä¢ ${item.title}\n  ‚Üí ${item.url}\n`;
        });
        formatted += '\n';
      }

      if (news.length > 0) {
        formatted += `üì∞ **Today's News:**\n`;
        news.forEach(item => {
          const hot = item.isHot ? 'üî• ' : '';
          formatted += `‚Ä¢ ${hot}${item.title} (${item.source})\n  ‚Üí ${item.url}\n`;
        });
        formatted += '\n';
      }

      if (toolOfTheDay) {
        formatted += `üí° **Tool/Resource of the Day:**\n`;
        formatted += `‚Ä¢ ${toolOfTheDay.title}\n  ‚Üí ${toolOfTheDay.url}\n`;
      }

      if (dontMiss.length === 0 && news.length === 0) {
        formatted += `_Quiet day in AI news. Check back later!_\n`;
      }

      formatted += `\n---\n_Generated by AI News Dashboard_`;
    }

    return NextResponse.json({
      date: today,
      greeting: getGreeting(),
      dontMiss,
      news,
      toolOfTheDay: toolOfTheDay ? {
        title: toolOfTheDay.title,
        url: toolOfTheDay.url,
        source: toolOfTheDay.source,
        isHot: toolOfTheDay.isHot || false,
      } : null,
      formatted,
      itemCount: dontMiss.length + news.length + (toolOfTheDay ? 1 : 0),
    });
  } catch (error) {
    console.error('Error generating digest:', error);
    
    return NextResponse.json({
      date: new Date().toISOString(),
      greeting: 'Hello',
      dontMiss: [],
      news: [],
      toolOfTheDay: null,
      formatted: '‚ùå Error generating digest. Please try again later.',
      itemCount: 0,
    }, { status: 500 });
  }
}
